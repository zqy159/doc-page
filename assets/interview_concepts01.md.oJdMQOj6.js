import{_ as i,c as s,o as e,ai as t}from"./chunks/framework.Ch_4mUWj.js";const u=JSON.parse('{"title":"基础概念","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"interview/concepts01.md","filePath":"interview/concepts01.md"}'),l={name:"interview/concepts01.md"};function n(h,a,r,p,o,k){return e(),s("div",null,a[0]||(a[0]=[t(`<h1 id="基础概念" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念" aria-label="Permalink to &quot;基础概念&quot;">​</a></h1><p>保持回答简洁、有对比、有场景，既能体现技术视野，又能展示实际价值。同时要注重理解。通过联想能力去阐述，去记忆基础框架和脉络。</p><h2 id="webpack-核心逻辑" tabindex="-1">Webpack 核心逻辑 <a class="header-anchor" href="#webpack-核心逻辑" aria-label="Permalink to &quot;Webpack 核心逻辑&quot;">​</a></h2><p>Webpack 是模块化打包工具，从入口文件出发，递归解析所有依赖，通过 Loader 处理各类文件（如 Vue/SCSS 转 JS），最终生成优化后的静态资源（如 bundle.js）。</p><p>Loader vs Plugin 角色：</p><p>Loader：专注单文件转换（如 .vue → JS 模块），按需处理特定类型文件。</p><p>Plugin：扩展全流程能力（如压缩代码、生成 HTML），通过钩子监听并修改构建行为。</p><p>一句话总结： Loader 做“翻译”（文件转换），Plugin 管“流程”（全局扩展），二者协作让 Webpack 既能处理复杂模块，又能灵活定制构建。</p><h2 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h2><p>Vite 是一个基于 原生 ES 模块 的前端构建工具，主打「极速启动」和「按需编译」，显著优化了开发体验。</p><ul><li>生产环境仍会打包（Rollup 优化），但开发体验是核心。</li><li>对比 Webpack：Vite 开发更快，但生态成熟度稍弱（可通过插件弥补）。</li><li>结合项目经验： “我在上家公司用 Vite 替代了 Webpack，项目启动时间从 30 秒降到 2 秒，HMR 几乎无感。”</li></ul><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><p>性能优化前端着重看的是 5 个方面,对资源的优化,对渲染的优化,对图片和媒体的优化,对构建和部署的优化,以及对用户体验的优化。</p><p><strong>1.对资源的优化:</strong></p><ul><li>减少 http 请求:合并文件，对代码的分割按需加载</li><li>压缩传输:启用 gzip 压缩,图片转更小的 webp 格式,以及 cdn 加速</li><li>智能加载：预加载,懒加载</li></ul><p><strong>2.对渲染的优化:</strong></p><ul><li>CSS 优化：避免阻塞渲染（CSS 放<code>&lt;head&gt;</code>）、减少复杂选择器、注重 css 规则和复用。</li><li>JS 优化: 减少 DOM 操作（批量更新/虚拟 DOM）、事件委托、异步加载第三方脚本、尽量减少回流和重绘。</li><li>防抖节流：高频事件（如滚动、输入）用防抖（Debounce）或节流（Throttle）控制频率。</li></ul><p><strong>回流:</strong> 当 dom 的变化，影响到了该元素在浏览器上的几何位置，导致页面重新布局和排列<br> （1） 添加，删除，和更新 dom 节点， （2） 使用 display:none 属性<br><strong>重绘:</strong> 当 dom 的变化只是外观发生了改变,没影响到页面的重新布局 （1）改变样式<br><strong>防抖:</strong> 是“等你不动了再执行” 延迟执行直至事件停止时触发,适用于避免重复操作。<br><strong>节流:</strong> 是“按固定频率执行”。限定执行频率,适用于控制高频事件执行间隔。<br><strong>如何优化和减少回流和重绘:</strong><br> （1）批量改变样式，改变 class<br> （2）减少 dom 的操作<br> （3）使用文档碎片,合并操作插入到文档流中<br> （4）使用 position：absolute 和 fixed 属性，脱离文档流不会影响其他元素的布局<br> （5）使用虚拟 dom<br> （6）使用 table 布局<br> （7）避免频繁改变窗口<br> （8）长列表采用虚拟滚动的方式</p><p><strong>3. 图片和媒体的优化</strong><br><strong>4. 构建和部署的优化</strong><br><strong>5. 用户体验的优化</strong></p><p>简述:</p><ol><li><p>对资源的优化<br> 合并,压缩js,css,html 使用精灵图， 对资源进行缓存 通过gzip压缩 按需加载，下拉加载，预加载 采用cdn资源</p></li><li><p>对于js的优化<br> 尽量减少对dom的操作，可以使用dom碎片 尽量减少回流和重绘 高频率事件增加，防抖和节流</p></li><li><p>对于css优化<br> 选择器不宜太过复杂 不滥用css属性 注重css的规则的复用</p></li></ol><h2 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h2><h3 id="http-的了解" tabindex="-1">http 的了解 <a class="header-anchor" href="#http-的了解" aria-label="Permalink to &quot;http 的了解&quot;">​</a></h3><p>http 是一个超文本传输协议,。网络层级分为应用层，传输层，网络层，链路层。http 协议处于应用层。https 属于 http 的加密协议，一般采用 SSL/TSL 进行加密进行传输。http 是一种无状态协议，因此进行数据传输时会携带一些参数。<br><strong>请求头：</strong> accept-encoding:客户端可以接收的编码类型,host:目标主机,cookie,referer:请求源,connection:连接源<br> cache-control:存储缓存相关. accpet:响应内容类型等<br><strong>返回头：</strong> contetn-type:服务器返回的内容类型，connection,status.<br><strong>get 请求：</strong> 通过 url 进行数据传输，传输相对来说不安全到家，传输速度较快，传输数据量少.只接受 ASCII 字符,会自动缓存接口。<br><strong>post 请求：</strong> 通过 body 进行数据传输，传输相对来说安全,传输速度较慢，传输数据量大。字符不受限制，不会自动缓存接口。</p><h3 id="长连接和短连接" tabindex="-1">长连接和短连接 <a class="header-anchor" href="#长连接和短连接" aria-label="Permalink to &quot;长连接和短连接&quot;">​</a></h3><p><strong>长连接:</strong> connection:keep-alive(http1.1 默认保持长连接，避过多 tcp 建立和关闭，减少开销 ， 一般对于频繁请求资源时长连接比较合适，服务器一般会限制长连接个数，以及保活时间)<br><strong>短连接:</strong> connection:close （http1.0 默认保持短连接，完成连接后会进行关闭，多用于并发量比较大，用户不会频繁请求的连接）</p><h3 id="进入网站的过程" tabindex="-1">进入网站的过程 <a class="header-anchor" href="#进入网站的过程" aria-label="Permalink to &quot;进入网站的过程&quot;">​</a></h3><ol><li>当输入域名后，浏览器会根据 dns（从浏览器，系统，以及 isp 中进行查找缓存）进行查找相应的 IP。</li><li>浏览器与服务器通过 tcp 的三次握手建立通信</li><li>浏览器会向服务器发送请求</li><li>服务器收到请求进行相应处理，将生成的 html 返回给客户端</li><li>客户端收到数据，浏览器对数据进行解析渲染，展现给用户。</li></ol><p>简述: 输入域名后，浏览器通过 DNS 逐级查询获取 IP，建立 TCP（或 TLS）连接，发送 HTTP 请求，服务器处理并返回资源，浏览器解析渲染后展示页面。</p><h3 id="浏览器安全的了解" tabindex="-1">浏览器安全的了解 <a class="header-anchor" href="#浏览器安全的了解" aria-label="Permalink to &quot;浏览器安全的了解&quot;">​</a></h3><p>常见的攻击浏览器的方法又 XSS 攻击和 csrf 攻击.<br> xss 是一种植入有威胁的代码进行攻击，可以通过数据转义的方式防止代码生效。<br> csrf 是一种通过第三方网站窃取自身的 cookie 对原本的用户信息做一些恶意破坏，解决方法可以通过请求头 referer 判断调用的接口源，以及对当前的 host 增加唯一的 path 源。</p><h3 id="浏览器-seo-优化的了解" tabindex="-1">浏览器 seo 优化的了解 <a class="header-anchor" href="#浏览器-seo-优化的了解" aria-label="Permalink to &quot;浏览器 seo 优化的了解&quot;">​</a></h3><p>设置 title desciption,keywords,使用语义化标签 header nav footer section 提高权重</p><h3 id="浏览器缓存机制的了解" tabindex="-1">浏览器缓存机制的了解 <a class="header-anchor" href="#浏览器缓存机制的了解" aria-label="Permalink to &quot;浏览器缓存机制的了解&quot;">​</a></h3><p>强制缓存，协商缓存 浏览器首次请求直接获取资源并存储缓存规则，后续请求优先使用未过期的强制缓存，失效时通过协商缓存验证资源更新。</p><h3 id="进程-线程-和协程" tabindex="-1">进程，线程，和协程 <a class="header-anchor" href="#进程-线程-和协程" aria-label="Permalink to &quot;进程，线程，和协程&quot;">​</a></h3><p>进程是操作系统中进行资源分配和调度的一个独立单位<br> 线程是进程中的一个执行路径或执行单元<br> 协程是一种比线程更轻量级的并发构造</p><h2 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h2><h3 id="mvvm-的理解" tabindex="-1">MVVM 的理解 <a class="header-anchor" href="#mvvm-的理解" aria-label="Permalink to &quot;MVVM 的理解&quot;">​</a></h3><p>M 数据层 V 视图层 VM 是构建视图层和数据层之间的桥梁 MVVM 设计理念是前端工程化的体现，是一种双向数据绑定的方式，数据层变化会影响表示层的展示，展示层的展示会影响数据层的变化。让前端的展示，尽可能通过数据层去操纵,使得前端的交互操作尽可能的从 dom 操作中解脱出来。</p><h3 id="vue-中如何运用-mvvm-模式" tabindex="-1">vue 中如何运用 MVVM 模式 <a class="header-anchor" href="#vue-中如何运用-mvvm-模式" aria-label="Permalink to &quot;vue 中如何运用 MVVM 模式&quot;">​</a></h3><p>vue 用了 MVVM 的设计理念进行设计</p><ol><li>当界面开始渲染时，会对数据进行劫持（Observer），通过(Object.defineProperty 对数据对象进行遍历或者 Proxy)，</li><li>对每个劫持的数据进行监听（Watchr）</li><li>当 Object.defineProperty 监听到数据的改变，触发 set 方法在执行对应的 watcher</li></ol><h3 id="对虚拟-dom-和-diff-算法的了解" tabindex="-1">对虚拟 dom 和 diff 算法的了解 <a class="header-anchor" href="#对虚拟-dom-和-diff-算法的了解" aria-label="Permalink to &quot;对虚拟 dom 和 diff 算法的了解&quot;">​</a></h3><p>虚拟 dom 是由真实 dom 转换成的一个对象，虚拟 dom 中的数据变换时会通过 diff 算法进行与旧的虚拟 dom 进行行差异性比较，再把 diff 结果表通过 DOM fragment 更新到浏览器 DOM 中 <code>Diff算法只是为了虚拟DOM比较替换效率更高</code></p><h3 id="diff算法" tabindex="-1">diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;diff算法&quot;">​</a></h3><p>Diff 算法是虚拟 DOM 更新视图的核心，它会对比新旧虚拟 DOM 树的差异，找出需要更新的最小 DOM 操作 在同一层层级中元素类型不同直接替换。列表渲染中通过key精准识别节点变换进行替换</p><h3 id="数据变化时-页面会经历什么" tabindex="-1">数据变化时，页面会经历什么 <a class="header-anchor" href="#数据变化时-页面会经历什么" aria-label="Permalink to &quot;数据变化时，页面会经历什么&quot;">​</a></h3><p>当数据发生变化时，会触发依赖该数据的watcher方法，重新渲染组件，生成新的虚拟dom 通过diff算法比较新旧的虚拟dom,进而更新节点内容更新真实dom</p><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><p>cors服务端接口配置允许访问的响应头<br> jsonp 浏览器script不受同源策略的影响进行访问<br> websocket建立持久连接<br> 通过nginx或者开发环境配置反向代理访问</p><h3 id="vue-和-react-对比" tabindex="-1">Vue 和 React 对比 <a class="header-anchor" href="#vue-和-react-对比" aria-label="Permalink to &quot;Vue 和 React 对比&quot;">​</a></h3><p>React：</p><ol><li>采用了单向数据流</li><li>react 采用的是 jsx 语法</li><li>react 需要通过 setState 方法修改属性</li></ol><p>Vue:</p><ol><li>v-model 采用了双向数据流的方式，</li><li>vue 使用模板解析</li><li>vue 可以直接对 this 修改属性 都是采用虚拟 dom 的方式,都支持组件化，都是数据驱动视图</li></ol><h3 id="自适应和响应式布局" tabindex="-1">自适应和响应式布局 <a class="header-anchor" href="#自适应和响应式布局" aria-label="Permalink to &quot;自适应和响应式布局&quot;">​</a></h3><p>自适应：自适应布局通过媒体查询加载预设固定布局版本。<br> 响应式：根据相对单位,弹性布局,以及媒体查询微调适配各个屏幕。</p><h3 id="vue-生命周期" tabindex="-1">vue 生命周期 <a class="header-anchor" href="#vue-生命周期" aria-label="Permalink to &quot;vue 生命周期&quot;">​</a></h3><ol><li>beforeCreate 初始化 Vue 实例</li><li>create:初始化 data 和 props,并且给对象绑定数据劫持</li><li>beforemounted(onBeforeMount): 可以获取到数据，但无法进行 dom 操作</li><li>mounted(onMounted):可以获取 dom，进行 dom 操作</li><li>beforeUpdated(onBeforeUpdate):监听数据的改变，获取到最新数据</li><li>updated(onUpdated):数据更新完毕可以获取到更新后的数据,</li><li>beforeDestory(onBeforeUnmount): 依然可以获取到数据，清理定时器，和事件监听资源</li><li>destoryed(onUnmounted): 组件销毁</li><li>actived(onActived) <code>keep-alive</code>缓存包裹组件激活触发的钩子</li><li>deactived(ondeactivated) <code>keep-alive</code>缓存被包裹组件脱离触发的钩子</li></ol><p>注：</p><ul><li>组合式 API：使用 onXxx 系列函数替代选项式 API，提升代码组织灵活性</li><li>setup 语法糖中没有对应的 beforecreate 钩子与 create 钩子</li></ul><h3 id="vue-父子组件执行顺序" tabindex="-1">vue 父子组件执行顺序 <a class="header-anchor" href="#vue-父子组件执行顺序" aria-label="Permalink to &quot;vue 父子组件执行顺序&quot;">​</a></h3><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><p>父组件挂在过程 父 beforeMount -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><p>子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><p>销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p><h3 id="vue-nexttick-的理解" tabindex="-1">vue.$nextTick 的理解 <a class="header-anchor" href="#vue-nexttick-的理解" aria-label="Permalink to &quot;vue.$nextTick 的理解&quot;">​</a></h3><p>vue 在更新 dom 时是异步进行执行的，因此当前方法用于处理 dom 加载完成执行的任务。</p><h3 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h3><p>keep-alive 是 vue 框架的一个内置组件，主要用于对组件内数据进行缓存。<br> 手动清除缓存：通过 v-if 为 flase 或者修改 key 强制渲染。</p><h3 id="组件内-data-方法" tabindex="-1">组件内 data 方法 <a class="header-anchor" href="#组件内-data-方法" aria-label="Permalink to &quot;组件内 data 方法&quot;">​</a></h3><p>data 必须是一个函数,返回一个对象,避免组件复用时状态污染。保持组件内数据的独立性</p><h3 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-label="Permalink to &quot;路由守卫&quot;">​</a></h3><p>vue 路由守卫</p><ol><li>全局守卫 beforeEach (权限控制登陆验证)</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态路由加载（根据角色）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 权限控制</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> roles</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUserRoles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.meta.roles </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">to.meta.roles.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roles)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/403&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无权限访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 登陆验证</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> localStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.meta.requiresAuth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">token) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, query: { redirect: to.fullPath } });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ol start="2"><li>路由独享守卫 beforeEnter</li><li>组件内守卫 beforeRouteEnter</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件内守卫加载数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { post: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeRouteEnter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fetchPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(to.params.id).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(post));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="vuerouter-的理解" tabindex="-1">vueRouter 的理解 <a class="header-anchor" href="#vuerouter-的理解" aria-label="Permalink to &quot;vueRouter 的理解&quot;">​</a></h3><ol><li>vue 路由分为 history 模式和 hash 模式，history 模式发到生产环境时需要配置服务器的跳转地址，不然会出现 404 页面</li><li>vue 提供了 router-link 进行跳转链接，也可以通过编程式导航$router.push 进行跳转（传递 params 时，必须加上 name,不然视为无效）<br> ( 1）router.push(&#39;home&#39;) // 字符串<br> ( 2 ) router.push({ path: &#39;home&#39; }) //对象<br> ( 3 ) router.push({ name: &#39;user&#39;, params: { userId: &#39;123&#39; }}) //命名的路由<br> ( 4 ) router.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }}) // 带查询参数，变成 /register?plan=private</li></ol><h3 id="route和-router-的区别" tabindex="-1">$route和$router 的区别？ <a class="header-anchor" href="#route和-router-的区别" aria-label="Permalink to &quot;$route和$router 的区别？&quot;">​</a></h3><p>$route是路由信息对象<br> $router 是路由实例包括路由的跳转的方法，和钩子函数。</p><h3 id="vue-改变数组触发视图更新" tabindex="-1">Vue 改变数组触发视图更新 <a class="header-anchor" href="#vue-改变数组触发视图更新" aria-label="Permalink to &quot;Vue 改变数组触发视图更新&quot;">​</a></h3><p>push(), pop(), shift(), unshift(), splice(), sort(), reverse(),Vue.set( target, key, value)</p><h3 id="watch-和-computed-的区别" tabindex="-1">watch 和 computed 的区别 <a class="header-anchor" href="#watch-和-computed-的区别" aria-label="Permalink to &quot;watch 和 computed 的区别&quot;">​</a></h3><p>1.watch 擅长处理的场景：一个数据影响多个数据<br> 2.computed 擅长处理的场景：一个数据受多个数据影响</p><h3 id="vuex-的理解" tabindex="-1">vuex 的理解 <a class="header-anchor" href="#vuex-的理解" aria-label="Permalink to &quot;vuex 的理解&quot;">​</a></h3><p>vuex 是 vue 框架的一个状态管理工具<br> 1.state 用来存储状态属性<br> 2.geeters 相当于状态属性的计算属性<br> 3.mutations 通过提交 mutation 的方式来改变状态数据，是因为我们想要更明确地追踪到状态的变化，因此这个方法内不能出现异步函数,异步方法一般放在 action 中<br> 4.action 可以用于执行异步操作，以及一些复杂的逻辑操作. 并且通过 commit 参数可以去改变 mutatios。<br> 5.module 状态管理模块化，每个模块内需要添加 namespaced: true<br> 调用方式<br> (1)...mapState(&#39;a&#39;) 字符串方式<br> (2)...mapState(&#39;a&#39;,[&#39;b&#39;]) 子模块方式<br> (3)...mapState({s:&#39;&#39;b&quot;}) 重命名方式<br> 触发 muaction: $store.commit(&#39;a/b&#39;,msg)<br> 触发action:$store.dispatch</p><h3 id="vue-优化" tabindex="-1">Vue 优化 <a class="header-anchor" href="#vue-优化" aria-label="Permalink to &quot;Vue 优化&quot;">​</a></h3><ol><li>路由懒加载，组件懒加载避免过多的全局引入。</li><li>采用 cdn 方式加载一些资源</li><li>打包的时候避免对 map 打包</li><li>首屏加载时采用 loading 和骨架屏减少等待焦虑</li><li>频繁切换的组件采用 keep-alive</li><li>组件卸载时清除监听事件和定时器</li></ol><h3 id="key属性的作用" tabindex="-1">key属性的作用 <a class="header-anchor" href="#key属性的作用" aria-label="Permalink to &quot;key属性的作用&quot;">​</a></h3><p>高效的更新和操作虚拟dom中的元素或组件,标识元素的唯一性,避免元素重复渲染。</p><h3 id="vue-指令的了解" tabindex="-1">vue 指令的了解 <a class="header-anchor" href="#vue-指令的了解" aria-label="Permalink to &quot;vue 指令的了解&quot;">​</a></h3><p>常见指令：v-for ,v-if ,v-show,v-bind,v-onv-model(表单的双向绑定)<br> 自定义指令：分别有组件内自定义指令，全局自定义指令<br> 钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）<br> 钩子函数参数：el、binding</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">binding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="vue-如何封装一个组件" tabindex="-1">vue 如何封装一个组件 <a class="header-anchor" href="#vue-如何封装一个组件" aria-label="Permalink to &quot;vue 如何封装一个组件&quot;">​</a></h3><p>合理的利用插槽，可以控制不同元素在组件的位置以及通过 template 中的 slot-scope 传递数据给调用的组件.单个插槽，具名插槽，和作用域插槽 通过 props 接收来自组件的值 <a href="https://blog.csdn.net/xiaolinlife/article/details/89517928" target="_blank" rel="noreferrer">https://blog.csdn.net/xiaolinlife/article/details/89517928</a></p><h3 id="vue-传值" tabindex="-1">vue 传值 <a class="header-anchor" href="#vue-传值" aria-label="Permalink to &quot;vue 传值&quot;">​</a></h3><p>vue 传值采用了发布订阅的方式<br> 父传子：通过属性进行传值。子组件通过 props 接收。<br> 子传父：父组件监听，子组件触发。<br> 非父子关系组件：可以使用一个新的 vue 实例挂载的 vue 的$center 上，进行传值<br> 也可以通过 vuex 进行传值<br> 深层父传子：provide inject<br> 发布订阅：pubsub-js</p><h3 id="vue-如何引入通过-use-引入插件" tabindex="-1">vue 如何引入通过 use 引入插件 <a class="header-anchor" href="#vue-如何引入通过-use-引入插件" aria-label="Permalink to &quot;vue 如何引入通过 use 引入插件&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> comtent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  installl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(comtent);</span></span></code></pre></div><h3 id="vue-loader-的作用" tabindex="-1">vue-loader 的作用 <a class="header-anchor" href="#vue-loader-的作用" aria-label="Permalink to &quot;vue-loader 的作用&quot;">​</a></h3><p>用来解析.vue 文件的一个加载 loader，template js style 文件解析成 js 模块</p><h3 id="vue-的-tenplate-编译的理解" tabindex="-1">vue 的 tenplate 编译的理解 <a class="header-anchor" href="#vue-的-tenplate-编译的理解" aria-label="Permalink to &quot;vue 的 tenplate 编译的理解&quot;">​</a></h3><p>先转化成 AST 树，在得到 render 函数返回的虚拟 dom 的节点,是用来声明虚拟 dom 的标签模板</p><h3 id="vue-element-ui-架构思想" tabindex="-1">vue+element-ui 架构思想 <a class="header-anchor" href="#vue-element-ui-架构思想" aria-label="Permalink to &quot;vue+element-ui 架构思想&quot;">​</a></h3><p>路由，全局过滤器，全局指令，全局插件，权限，公共组件，接口管理，请求拦截</p><h3 id="封装过哪些组件" tabindex="-1">封装过哪些组件 <a class="header-anchor" href="#封装过哪些组件" aria-label="Permalink to &quot;封装过哪些组件&quot;">​</a></h3><p>虚拟滚动组件，上拉加载下拉刷新组件，term 封装 cmd 窗口组件，集成封装过简单的编辑器，封装过简单的 UI 组件库,</p><h3 id="自研过哪些项目" tabindex="-1">自研过哪些项目 <a class="header-anchor" href="#自研过哪些项目" aria-label="Permalink to &quot;自研过哪些项目&quot;">​</a></h3><ol><li>仿造神策等工具，写过可视化埋点sdk.</li><li>仿造badjs写过，监控上报sdk</li><li>通过electron写过简单的编辑器，截图解析文字系统。</li><li>通过脚手架写过模板搭建工程，以及一键发布工程</li><li>通过egg+mysql等一些工具写过自动化构建发布系统</li></ol><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><h3 id="axios-拦截器如何避免重复请求" tabindex="-1">axios 拦截器如何避免重复请求 <a class="header-anchor" href="#axios-拦截器如何避免重复请求" aria-label="Permalink to &quot;axios 拦截器如何避免重复请求&quot;">​</a></h3><p>请求通过拦截器存储 url,响应时删除。再次请求时,判断是否有重复的 URL,如果有终止第一次的请求。</p><h3 id="前端加密方式的了解" tabindex="-1">前端加密方式的了解 <a class="header-anchor" href="#前端加密方式的了解" aria-label="Permalink to &quot;前端加密方式的了解&quot;">​</a></h3><p>前端常用的加密方式有 SHA-256 盐值加密密码,对称加密(AES)和非对称加密(RSA)</p><p><strong>密码安全:</strong> 前端哈希需结合盐值，后端二次处理；<br><strong>传输安全:</strong> 依赖 HTTPS，避免本地加密替代传输层保护；<br><strong>密钥管理:</strong> 前端无法安全存储密钥，敏感操作应交给后端。<br> 此外，需避免使用已淘汰算法（如 MD5），并始终将前端加密视为整体安全链路的一环。”</p><p><strong>1. 哈希算法加密</strong><br> 常见算法:SHA-256 原理: 将数据转化为哈希值，一般用以登录 密码+随机值 通过 hash 转化存储。</p><p>注册场景:<br> （1） 用户输入密码。<br> （2） 前端生成随机盐值（salt）。<br> （3） 计算 hash = SHA256(密码 + salt)。<br> （4） 将 hash 和 salt 发送到后端。<br> （5） 后端再次对 hash 进行哈希（如 SHA256(hash + 后端盐值)）并存储。</p><p>登录场景:<br> （1）用户输入用户名和密码。<br> （2）前端向后端请求该用户的 salt。<br> （3）前端计算 hash = SHA256(密码 + salt)。<br> （4）将 hash 发送到后端验证。</p><p><strong>2. 对称加密（Symmetric Encryption）</strong><br> 常见算法:AES<br> 原理：加密和解密使用同一个密钥。 特性：高效加密大量数据，但密钥分发困难。</p><p><strong>3. 非对称加密（Asymmetric Encryption）</strong><br> 常见算法:RSA<br> 原理：使用公钥加密、私钥解密（或私钥签名、公钥验签)。 特性：安全交换密钥，但速度慢。</p><p><strong>4. 对称密钥与非对称密钥结合</strong><br> （1）客户端随机生成一个对称密钥<br> （2）通过公钥加密对称密钥传输给服务器<br> （3）服务器再用私钥解密对称密钥<br> （4）双方后续使用该对称密钥加密传输数据<br> 客户端生成预主密钥 → RSA 公钥加密 → 发送给服务器。<br> 服务器私钥解密 → 双方基于预主密钥 + 随机数生成会话密钥。</p><h3 id="虚拟滚动" tabindex="-1">虚拟滚动 <a class="header-anchor" href="#虚拟滚动" aria-label="Permalink to &quot;虚拟滚动&quot;">​</a></h3><p>根据可视内容滚动位置，来渲染长列表数据中的某一部分元素。<br> 实现方式：当虚拟盒子滚动时，去垂直移动装有数据的盒子，并且改变数据保证，移动的数据与展示盒子展示的位置对应。</p>`,126)]))}const c=i(l,[["render",n]]);export{u as __pageData,c as default};
